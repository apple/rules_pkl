# Copyright Â© 2025 Apple Inc. and the Pkl project authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Implementation for 'pkl_java_library' macro.
"""

load("@rules_java//java:defs.bzl", "JavaInfo", "java_import", "java_library")
load("@rules_java//java:java_single_jar.bzl", "java_single_jar")
load("@rules_pkl//pkl/private:providers.bzl", "PklCacheInfo", "PklFileInfo")

def _to_short_path(f, _expander):
    return f.tree_relative_path + "=" + f.path

# TODO: Investigate if this can be replaced with `pkg_zip` from `rules_pkg`.
def _zipit(ctx, outfile, srcs):
    zip_args = ctx.actions.args()
    zip_args.add_all("cC", [outfile.path])
    zip_args.add_all(srcs, map_each = _to_short_path)
    ctx.actions.run(
        inputs = srcs,
        outputs = [outfile],
        executable = ctx.executable._zip,
        arguments = [zip_args],
        progress_message = "Writing via zip: %s" % outfile.basename,
    )

def _pkl_java_src_jar_impl(ctx):
    modules = depset(transitive = [depset(dep[JavaInfo].runtime_output_jars) for dep in ctx.attr.module_path]).to_list()
    java_codegen_toolchain = ctx.toolchains["//pkl:codegen_toolchain_type"]

    # Generate Java from Pkl
    outdir = ctx.actions.declare_directory(ctx.attr.name, sibling = None)
    gen_args = ctx.actions.args()

    gen_args.add("--no-cache")
    if len(modules):
        gen_args.add_all(["--module-path", ctx.configuration.host_path_separator.join([module.path for module in modules])])
    if ctx.attr.generate_getters:
        gen_args.add_all(["--generate-getters"])
    gen_args.add_all("-o", [outdir.path])
    gen_args.add_all(ctx.files.srcs)

    ctx.actions.run(
        inputs = ctx.files.srcs + modules,
        outputs = [outdir],
        executable = java_codegen_toolchain.codegen_cli,
        arguments = [gen_args],
        tools = [
            java_codegen_toolchain.cli_files_to_run,
        ],
        progress_message = "Generating Java sources from Pkl %s" % (ctx.label),
    )

    # Create JAR
    outjar = ctx.outputs.out
    _zipit(
        ctx = ctx,
        outfile = ctx.outputs.out,
        srcs = [outdir],
    )

    # Return JAR
    return OutputGroupInfo(out = [outjar])

_pkl_java_src_jar = rule(
    _pkl_java_src_jar_impl,
    doc = """Create a JAR containing the generated Java source files from Pkl files.

        Args:
          name: A unique name for this target.
          srcs: The Pkl source files used to generate the Java source files.
          module_path: List of Java module targets. Must export provide the JavaInfo provider.
          **kwargs: Further keyword arguments. E.g. visibility.
        """,
    attrs = {
        "srcs": attr.label_list(
            mandatory = True,
            allow_files = [".pkl"],
            doc = "The Pkl source files.",
        ),
        "generate_getters": attr.bool(
            doc = "Whether to generate getters in the AppConfig. Defaults to True",
            default = True,
        ),
        "module_path": attr.label_list(
            providers = [
                [JavaInfo],
            ],
            doc = "List of Java module targets. Must export provide the JavaInfo provider.",
        ),
        "out": attr.output(
            doc = "The output JAR generated by this action.",
        ),
        "_zip": attr.label(
            allow_single_file = True,
            cfg = "exec",
            default = "@bazel_tools//tools/zip:zipper",
            executable = True,
        ),
    },
    toolchains = [
        "//pkl:codegen_toolchain_type",
    ],
)

def _pkl_java_resource_jar_impl(ctx):
    srcjar = ctx.file.srcjar
    resource_jar = ctx.outputs.out

    # Use zipper to extract and repackage, stripping the resources/ prefix
    ctx.actions.run_shell(
        inputs = [srcjar],
        outputs = [resource_jar],
        tools = [ctx.executable._zipper],
        command = """
            set -e
            EXECROOT="$PWD"
            ZIPPER="$EXECROOT/$1"
            SRCJAR="$EXECROOT/$2"
            OUTJAR="$EXECROOT/$3"

            TMPDIR=$(mktemp -d)
            trap "rm -rf $TMPDIR" EXIT

            # Extract srcjar using zipper
            cd "$TMPDIR"
            "$ZIPPER" x "$SRCJAR"

            # Create resource JAR with resources/ prefix stripped
            if [ -d "resources" ]; then
                cd resources
                # Find all files, excluding directories, and remove ./ prefix
                FILES=$(find . -type f | sed 's|^\\./||')
                if [ -n "$FILES" ]; then
                    "$ZIPPER" c "$OUTJAR" $FILES
                else
                    # Create empty JAR if resources directory is empty
                    cd "$TMPDIR"
                    touch empty.txt
                    "$ZIPPER" c "$OUTJAR" empty.txt
                fi
            else
                # Create empty JAR if no resources directory exists
                touch empty.txt
                "$ZIPPER" c "$OUTJAR" empty.txt
            fi
        """,
        arguments = [ctx.executable._zipper.path, srcjar.path, resource_jar.path],
        progress_message = "Extracting resources from %s" % ctx.label,
    )

    return [DefaultInfo(files = depset([resource_jar]))]

_pkl_java_resource_jar = rule(
    implementation = _pkl_java_resource_jar_impl,
    doc = "Extracts resources from a Pkl-generated srcjar",
    attrs = {
        "srcjar": attr.label(
            allow_single_file = [".srcjar"],
            mandatory = True,
            doc = "The srcjar containing resources/ directory",
        ),
        "out": attr.output(
            mandatory = True,
            doc = "Output resource JAR",
        ),
        "_zipper": attr.label(
            allow_single_file = True,
            cfg = "exec",
            default = "@bazel_tools//tools/zip:zipper",
            executable = True,
        ),
    },
)

def pkl_java_library(name, srcs, module_path = [], generate_getters = None, deps = [], pkl_java_deps = [Label("//pkl/private:pkl-config-java-internal")], tags = [], **kwargs):
    """Create a compiled JAR of Java source files generated from Pkl source files.

    Args:
        name: A unique name for this target.
        srcs: The Pkl files that are used to generate the Java source files.
        module_path: List of Java module targets. Must export provide the JavaInfo provider.
        generate_getters: Generate private final fields and public getter methods instead of public final fields. Defaults to True.
        deps: Other targets to include in the Pkl module path when building this Java library. Must be pkl_* targets.
        pkl_java_deps: The Pkl `java_library` targets to include in the produced Java library as deps. Must be `JavaInfo` targets. Defaults to an internal `pkl-config-java` label.
        tags: Bazel tags to add to this target.
        **kwargs: Further keyword arguments. E.g. visibility.
    """
    depsets = [depset([dep]) for dep in deps if PklFileInfo in dep or PklCacheInfo in dep]
    if len(depsets) != len(deps):
        fail("`deps` were provided, but there were no `PklFileInfo` or `PklCacheInfo` providers present within:", deps)

    name_generated_code = name + "_pkl"
    name_resources = name + "_resources"
    name_java_compiled = name + "_compiled"

    # Step 1: Generate Java sources and resources into srcjar
    _pkl_java_src_jar(
        name = name_generated_code,
        srcs = srcs,
        generate_getters = generate_getters,
        module_path = module_path,
        out = "{name}_codegen.srcjar".format(name = name_generated_code),
        tags = tags,
    )

    # Step 2: Extract resources from srcjar
    _pkl_java_resource_jar(
        name = name_resources,
        srcjar = name_generated_code,
        out = "{name}_resources.jar".format(name = name),
        tags = tags,
    )

    # As this is a macro, make sure we're only dealing with labels.
    pkl_java_deps = [Label(dep) for dep in pkl_java_deps]

    # Ensure that there are no duplicate entries in the deps
    all_deps = depset(
        pkl_java_deps + [native.package_relative_label(m) for m in module_path],
        transitive = depsets,
    )

    # Step 3: Compile Java sources
    java_library(
        name = name_java_compiled,
        srcs = [name_generated_code],
        resources = srcs,
        deps = all_deps.to_list(),
        tags = tags + [] if "no-lint" in tags else ["no-lint"],
        **kwargs
    )

    # Step 4: Merge compiled JAR and resource JAR
    name_merged = name + "_merged"
    java_single_jar(
        name = name_merged,
        deps = [
            name_java_compiled,
            name_resources,
        ],
        tags = tags,
    )

    # Step 5: Wrap in java_import to provide JavaInfo
    java_import(
        name = name,
        jars = [name_merged],
        deps = all_deps.to_list(),
        tags = tags,
        **kwargs
    )
